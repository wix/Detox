"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1533],{11470:(e,t,n)=>{n.d(t,{A:()=>w});var a=n(58168),r=n(96540),i=n(20053),o=n(23104),s=n(56347),l=n(57485),p=n(31682),g=n(89466);function c(e){return function(e){return r.Children.map(e,e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}(e).map(({props:{value:e,label:t,attributes:n,default:a}})=>({value:e,label:t,attributes:n,default:a}))}function u(e){const{values:t,children:n}=e;return(0,r.useMemo)(()=>{const e=t??c(n);return function(e){const t=(0,p.X)(e,(e,t)=>e.value===t.value);if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[t,n])}function d({value:e,tabValues:t}){return t.some(t=>t.value===e)}function m({queryString:e=!1,groupId:t}){const n=(0,s.W6)(),a=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,l.aZ)(a),(0,r.useCallback)(e=>{if(!a)return;const t=new URLSearchParams(n.location.search);t.set(a,e),n.replace({...n.location,search:t.toString()})},[a,n])]}function h(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,i=u(e),[o,s]=(0,r.useState)(()=>function({defaultValue:e,tabValues:t}){if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!d({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const n=t.find(e=>e.default)??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:i})),[l,p]=m({queryString:n,groupId:a}),[c,h]=function({groupId:e}){const t=function(e){return e?`docusaurus.tab.${e}`:null}(e),[n,a]=(0,g.Dv)(t);return[n,(0,r.useCallback)(e=>{t&&a.set(e)},[t,a])]}({groupId:a}),y=(()=>{const e=l??c;return d({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)(()=>{y&&s(y)},[y]);return{selectedValue:o,selectValue:(0,r.useCallback)(e=>{if(!d({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);s(e),p(e),h(e)},[p,h,i]),tabValues:i}}var y=n(92303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function N({className:e,block:t,selectedValue:n,selectValue:s,tabValues:l}){const p=[],{blockElementScrollPositionUntilNextRender:g}=(0,o.a_)(),c=e=>{const t=e.currentTarget,a=p.indexOf(t),r=l[a].value;r!==n&&(g(t),s(r))},u=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=p.indexOf(e.currentTarget)+1;t=p[n]??p[0];break}case"ArrowLeft":{const n=p.indexOf(e.currentTarget)-1;t=p[n]??p[p.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":t},e)},l.map(({value:e,label:t,attributes:o})=>r.createElement("li",(0,a.A)({role:"tab",tabIndex:n===e?0:-1,"aria-selected":n===e,key:e,ref:e=>p.push(e),onKeyDown:u,onClick:c},o,{className:(0,i.A)("tabs__item",f.tabItem,o?.className,{"tabs__item--active":n===e})}),t??e)))}function v({lazy:e,children:t,selectedValue:n}){const a=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){const e=a.find(e=>e.props.value===n);return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},a.map((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n})))}function b(e){const t=h(e);return r.createElement("div",{className:(0,i.A)("tabs-container",f.tabList)},r.createElement(N,(0,a.A)({},e,t)),r.createElement(v,(0,a.A)({},e,t)))}function w(e){const t=(0,y.A)();return r.createElement(b,(0,a.A)({key:String(t)},e))}},15680:(e,t,n)=>{n.d(t,{xA:()=>g,yg:()=>m});var a=n(96540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},g=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef(function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,g=s(e,["components","mdxType","originalType","parentName"]),c=p(n),d=r,m=c["".concat(l,".").concat(d)]||c[d]||u[d]||i;return n?a.createElement(m,o(o({ref:t},g),{},{components:n})):a.createElement(m,o({ref:t},g))});function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},19365:(e,t,n)=>{n.d(t,{A:()=>o});var a=n(96540),r=n(20053);const i={tabItem:"tabItem_Ymn6"};function o({children:e,hidden:t,className:n}){return a.createElement("div",{role:"tabpanel",className:(0,r.A)(i.tabItem,n),hidden:t},e)}},47962:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/jest-diagram-runInBand-b0e7564080d4f6a0a03e4dbcf6b0da7f.svg"},50765:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/boot-cli-single-worker-6672b7356e2146d40f39f80145780949.svg"},71198:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/jest-diagram-d957dd3e62301816b44197ef0a4abee0.svg"},82373:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/boot-cli-many-workers-95ab2193ce10864c0742f01ffd30b58b.svg"},82415:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/boot-jest-many-workers-ce60aaacc2101a9b810d2d22fe0df51b.svg"},85287:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/boot-jest-single-worker-278e1383ad4f31570f073fa12689aec6.svg"},94836:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>x,contentTitle:()=>b,default:()=>D,frontMatter:()=>v,metadata:()=>w,toc:()=>C});var a=n(58168),r=(n(96540),n(15680)),i=n(11470),o=n(19365);const s={toc:[]},l="wrapper";function p({components:e,...t}){return(0,r.yg)(l,(0,a.A)({},s,t,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"UML sequence diagram",src:n(82373).A,width:"1190",height:"831"})))}p.isMDXComponent=!0;const g={toc:[]},c="wrapper";function u({components:e,...t}){return(0,r.yg)(c,(0,a.A)({},g,t,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"UML sequence diagram",src:n(82415).A,width:"962",height:"682"})))}u.isMDXComponent=!0;const d={toc:[]},m="wrapper";function h({components:e,...t}){return(0,r.yg)(m,(0,a.A)({},d,t,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"UML sequence diagram",src:n(50765).A,width:"842",height:"743"})))}h.isMDXComponent=!0;const y={toc:[]},f="wrapper";function N({components:e,...t}){return(0,r.yg)(f,(0,a.A)({},y,t,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"UML sequence diagram",src:n(85287).A,width:"598",height:"565"})))}N.isMDXComponent=!0;const v={},b="Internals API",w={unversionedId:"api/internals",id:"version-20.x/api/internals",title:"Internals API",description:"This section might be more volatile than the other ones, yet we'll do our best to adhere to Semantic Release standards even here.",source:"@site/versioned_docs/version-20.x/api/internals.mdx",sourceDirName:"api",slug:"/api/internals",permalink:"/Detox/docs/api/internals",draft:!1,editUrl:"https://github.com/wix/Detox/edit/master/docs/versioned_docs/version-20.x/api/internals.mdx",tags:[],version:"20.x",frontMatter:{},sidebar:"apiSidebar",previous:{title:"Wix Pilot",permalink:"/Detox/docs/api/pilot"},next:{title:"Design Principles",permalink:"/Detox/docs/articles/design-principles"}},x={},C=[{value:"Lifecycle",id:"lifecycle",level:2},{value:"Jest lifecycle",id:"jest-lifecycle",level:3},{value:"Detox lifecycle",id:"detox-lifecycle",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>resolveConfig([options])</code> [Promise&lt;RuntimeConfig&gt;]",id:"resolveconfigoptions-promiseruntimeconfig",level:3},{value:"<code>getStatus()</code> [enum]",id:"getstatus-enum",level:3},{value:"<code>init([options])</code> [Promise]",id:"initoptions-promise",level:3},{value:"<code>installWorker([options])</code> [Promise]",id:"installworkeroptions-promise",level:3},{value:"<code>uninstallWorker()</code> [Promise]",id:"uninstallworker-promise",level:3},{value:"<code>cleanup()</code> [Promise]",id:"cleanup-promise",level:3},{value:"Optional lifecycle",id:"optional-lifecycle",level:2},{value:"<code>reportTestResults(array)</code> [Promise]",id:"reporttestresultsarray-promise",level:3},{value:"<code>onRunDescribeStart(event)</code> [Promise]",id:"onrundescribestartevent-promise",level:3},{value:"<code>onTestStart(event)</code> [Promise]",id:"onteststartevent-promise",level:3},{value:"<code>onHookFailure(event)</code> [Promise]",id:"onhookfailureevent-promise",level:3},{value:"<code>onTestFnFailure(event)</code> [Promise]",id:"ontestfnfailureevent-promise",level:3},{value:"<code>onTestDone(event)</code> [Promise]",id:"ontestdoneevent-promise",level:3},{value:"<code>onRunDescribeFinish(event)</code> [Promise]",id:"onrundescribefinishevent-promise",level:3},{value:"Properties",id:"properties",level:2},{value:"<code>config</code> [RuntimeConfig]",id:"config-runtimeconfig",level:3},{value:"<code>session</code> [SessionState]",id:"session-sessionstate",level:3},{value:"<code>log</code> [Logger]",id:"log-logger",level:3},{value:"<code>tracing</code>",id:"tracing",level:3},{value:"<code>tracing.createEventStream()</code>",id:"tracingcreateeventstream",level:4},{value:"<code>worker</code> [object]",id:"worker-object",level:3}],k={toc:C},j="wrapper";function D({components:e,...t}){return(0,r.yg)(j,(0,a.A)({},k,t,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"internals-api"},"Internals API"),(0,r.yg)("admonition",{type:"caution"},(0,r.yg)("p",{parentName:"admonition"},"This section might be more volatile than the other ones, yet we'll do our best to adhere to Semantic Release standards even here.")),(0,r.yg)("p",null,"Detox Internals might be useful for developing advanced enterprise presets or when you are planning to integrate with a third-party test runner like ",(0,r.yg)("a",{parentName:"p",href:"https://mochajs.org"},"Mocha"),", ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/avajs/ava"},"Ava"),", ",(0,r.yg)("a",{parentName:"p",href:"https://vitest.dev"},"Vitest")," or other ones."),(0,r.yg)("h2",{id:"lifecycle"},"Lifecycle"),(0,r.yg)("p",null,"The purpose of ",(0,r.yg)("strong",{parentName:"p"},"Internals API")," is mostly to align the lifecycles of Detox and a test runner underneath.\nAlthough it is generic enough, there is no denying that its design has been influenced by our official integration with Jest test runner.\nThat's why it might be better to start the overview from Jest lifecycle first, and then move on to Detox lifecycle and how they fit together."),(0,r.yg)("h3",{id:"jest-lifecycle"},"Jest lifecycle"),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"UML sequence diagram",src:n(71198).A,width:"717",height:"594"})),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Jest's main process starts from resolving and evaluating its config file, e.g. ",(0,r.yg)("inlineCode",{parentName:"p"},"jest.config.js"),":"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-js"},"module.exports = async function () {\n  return {\n    globalSetup: '/path/to/globalSetup.js',\n    globalTeardown: '/path/to/globalTeardown.js',\n    reporters: ['/path/to/reporter.js'],\n    /* ... jest config ... */\n  };\n};\n"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"If a ",(0,r.yg)("a",{parentName:"p",href:"https://jestjs.io/docs/configuration#globalsetup-string"},(0,r.yg)("inlineCode",{parentName:"a"},"globalSetup"))," handler is defined, it is resolved and executed in the main process:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-js"},"module.exports = async function () {\n  // ... global setup code ...\n};\n"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"The next come ",(0,r.yg)("a",{parentName:"p",href:"https://jestjs.io/docs/configuration#reporters-arraymodulename--modulename-options"},(0,r.yg)("inlineCode",{parentName:"a"},"reporters")),", one of the longest-living entities in the test session. After instantiating reporters, Jest calls their ",(0,r.yg)("inlineCode",{parentName:"p"},"onRunStart")," method:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-js"},"class Reporter {\n  async onRunStart(aggregatedResults, options) {\n    // ... reporter code ...\n  }\n\n  // ...\n};\n"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"If Jest is not running in band (see ",(0,r.yg)("a",{parentName:"p",href:"https://jestjs.io/docs/cli#--runinband"},(0,r.yg)("inlineCode",{parentName:"a"},"-i, --runInBand")),"), and if it has ",(0,r.yg)("em",{parentName:"p"},"N")," ",(0,r.yg)("a",{parentName:"p",href:"https://jestjs.io/docs/configuration#maxworkers-number--string"},"workers")," (",(0,r.yg)("em",{parentName:"p"},"N > 1"),"), then it spawns ",(0,r.yg)("em",{parentName:"p"},"N")," child processes that keep taking test files one after another, running their tests inside and reporting back to the reporters:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-js"},"class Reporter {\n  async onTestFileResult(test, testResult, aggregatedResult) {\n    // ... reporter code ...\n  }\n\n  // ...\n};\n")),(0,r.yg)("p",{parentName:"li"},"Otherwise, Jest runs all the tests in the main process without spawning any other processes, but the reporting flow itself remains the same, as can be seen in the diagram:"),(0,r.yg)("p",{parentName:"li"},(0,r.yg)("img",{alt:"UML sequence diagram",src:n(47962).A,width:"591",height:"616"}))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"After all the tests have been executed, Jest calls ",(0,r.yg)("inlineCode",{parentName:"p"},"onRunComplete")," in the reporters, and this is the final phase for any reporter:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-js"},"class Reporter {\n  async onRunComplete(testContexts, results) {\n    // ... reporter code ...\n  }\n\n  // ...\n};\n"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"The last user-controlled hook is the global teardown. If a ",(0,r.yg)("a",{parentName:"p",href:"https://jestjs.io/docs/configuration#globalteardown-string"},(0,r.yg)("inlineCode",{parentName:"a"},"globalTeardown"))," handler is defined, it is resolved and executed in the main process:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-js"},"module.exports = async function () {\n  // ... global teardown code ...\n};\n")))),(0,r.yg)("h3",{id:"detox-lifecycle"},"Detox lifecycle"),(0,r.yg)("p",null,"Theoretically, Detox CLI could be totally agnostic about the test runner under the hood, but that would deprive us of some convenience.\nFor instance, there is a ",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/config/testRunner#testrunnerretries-number"},"retry mechanism"),", built into Detox CLI, which can schedule extra runs for failed test files.\nThis requirement obliges Detox context to live longer than any test runner, and requires from the test runner to be able to report back to Detox CLI, whereas the resulting child process hierarchy can be broad and multi-tiered, e.g.:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-plain",metastring:"text",text:!0},"\u2514\u2500\u2500 detox test ...\n    \u2514\u2500\u2500 jest ... --maxWorkers N\n        \u251c\u2500\u2500 jest-worker (1)\n        \u251c\u2500\u2500 ...\n        \u2514\u2500\u2500 jest-worker (N)\n")),(0,r.yg)("p",null,"Even if we run Jest directly, without Detox CLI, there's still a one-to-many relationship between its processes:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-plain",metastring:"text",text:!0},"\u2514\u2500\u2500 jest ... --maxWorkers N\n    \u251c\u2500\u2500 jest-worker (1)\n    \u251c\u2500\u2500 ...\n    \u2514\u2500\u2500 jest-worker (N)\n")),(0,r.yg)("p",null,"So, if we want to be on the safe side, every process should be able to communicate with the root process, where we have the primary context of Detox, and vice versa.\nRetrying failed tests is just one of numerous needs, and there are more:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"the primary context (and workers themselves, at times) needs to know how many workers are there;"),(0,r.yg)("li",{parentName:"ul"},"the workers should request from the primary context to allocate a device and return it back when they are done;"),(0,r.yg)("li",{parentName:"ul"},"any secondary context should be able to tell whether this is a first time it is running, or it is an ",(0,r.yg)("em",{parentName:"li"},"N"),"-th attempt already;")),(0,r.yg)("p",null,"This list can be continued and might expand even more with time, but the point is that Detox contexts will get instantiated as many times as child processes are created during the test session, and it should be something trivial to synchronize the primary and the secondary contexts to ensure a seamless experience."),(0,r.yg)("p",null,'It is worth mentioning that Jest\'s main process is ill-suited for taking a device and running the tests, as its purpose is to orchestrate the entire test session and not run the tests themselves.\nThis means that not all secondary contexts of Detox are "born equal" \u2013 most of them will be allocating a device for running tests, but at least one will be merely communicating with the primary context.'),(0,r.yg)("p",null,"This is exactly the reason why we call ",(0,r.yg)("a",{parentName:"p",href:"#initoptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"init()"))," in every child process, but sometimes it is not just a simple call, but an ",(0,r.yg)("a",{parentName:"p",href:"#initoptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"init({ workerId: null })"))," override to avoid creating a worker.\nHowever, the fact of initializing without a worker does not mean we can't call ",(0,r.yg)("a",{parentName:"p",href:"#installworkeroptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"installWorker()"))," later. For example, if it turns out that Jest is running in a single process, then instead of creating two Detox contexts within the same process, we're going to reuse the existing one and just supplement it with the worker itself."),(0,r.yg)("p",null,"There's one more implicit thing that happens at the very beginning of ",(0,r.yg)("a",{parentName:"p",href:"#initoptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"init([options])"))," method, and that is the config resolution. It is also available as a separate method, ",(0,r.yg)("a",{parentName:"p",href:"#resolveconfigoptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"resolveConfig([options])"))," based on the following considerations.\nWhen you use a test runner directly, without Detox CLI (e.g. ",(0,r.yg)("inlineCode",{parentName:"p"},"jest \u2026")," instead of ",(0,r.yg)("inlineCode",{parentName:"p"},"detox test \u2026"),"), then the test runner config gets resolved earlier than Detox config itself. That creates a dangerous scenario for dynamically generated configs:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js",metastring:'title="jest.config.js"',title:'"jest.config.js"'},"const { config } = require('detox/internals');\n\nmodule.exports = async () => {\n  if (config.device.type === 'ios.simulator') {\n    return { /* iOS-specific preset */ };\n  } else {\n    return { /* Android-specific preset */ };\n  }\n};\n")),(0,r.yg)("p",null,"The problem in this case is that we are accessing an unresolved (yet) config. Of course, one could assume that it is possible to overcome with a plain ",(0,r.yg)("a",{parentName:"p",href:"#initoptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"init()"))," call like this:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js",metastring:'title="bad-idea.config.js"',title:'"bad-idea.config.js"'},"const { init, config } = require('detox/internals');\n\nmodule.exports = async () => {\n  await init();\n\n  if (config.device.type === 'ios.simulator') {\n    // ... use config now ...\n  }\n};\n")),(0,r.yg)("p",null,"This solution will work, but it is rather a bad one, since Jest config resolution is an asymmetrical step compared to ",(0,r.yg)("inlineCode",{parentName:"p"},"globalSetup")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"globalTeardown"),". While solving one problem, it creates another one. Consider running this:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sh"},"jest --config bad-idea.config.js --showConfig\n")),(0,r.yg)("p",null,"For reference, when Jest runs with a ",(0,r.yg)("a",{parentName:"p",href:"https://jestjs.io/docs/cli#--showconfig"},(0,r.yg)("inlineCode",{parentName:"a"},"--showConfig"))," option, all it does is ",(0,r.yg)("em",{parentName:"p"},"to resolve the config and to print it"),". Hence, neither ",(0,r.yg)("a",{parentName:"p",href:"https://jestjs.io/docs/configuration#globalsetup-string"},(0,r.yg)("inlineCode",{parentName:"a"},"globalSetup"))," nor ",(0,r.yg)("a",{parentName:"p",href:"https://jestjs.io/docs/configuration#globalteardown-string"},(0,r.yg)("inlineCode",{parentName:"a"},"globalTeardown"))," will be called, and the test runner will hang up since there's no one to call the ",(0,r.yg)("a",{parentName:"p",href:"#cleanup-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"cleanup()"))," method which stops the ",(0,r.yg)("a",{parentName:"p",href:"https://www.npmjs.com/package/node-ipc"},"IPC server")," used for the communication between the primary and the secondary contexts."),(0,r.yg)("p",null,"Still, we have to be able to access the config early, and that is exactly why ",(0,r.yg)("a",{parentName:"p",href:"#initoptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"init()"))," method is a composite of ",(0,r.yg)("a",{parentName:"p",href:"#resolveconfigoptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"resolveConfig()")),", the ",(0,r.yg)("em",{parentName:"p"},"actual")," init, and ",(0,r.yg)("a",{parentName:"p",href:"#installworkeroptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"installWorker()")),". We could describe what it does on the high level with the following pseudocode:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"async function init(options = {}) {\n  config = config || await resolveConfig();\n\n  await logger.init(config);\n  await ipcServer.init(config);\n  // ... init more things  ...\n\n  if (options.workerId != null) {\n    await installWorker();\n  }\n}\n")),(0,r.yg)("p",null,"In other words, it will resolve config only if it has not been resolved before, and install a worker unless it has been forbidden explicitly.\nAnd even that we can ",(0,r.yg)("a",{parentName:"p",href:"#installworkeroptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"installWorker()"))," later if we ever need it."),(0,r.yg)("p",null,"Now, when many details are clarified, we can review the actual sequence diagrams step by step. There are four scenarios depending on the initiator (Detox CLI or the test runner itself) and on child process hierarchy (a single process or parent-children)."),(0,r.yg)("p",null,"A few words about the diagram and its conventions:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The ",(0,r.yg)("inlineCode",{parentName:"li"},"ClassName.0"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"ClassName.1"),", \u2026, ",(0,r.yg)("inlineCode",{parentName:"li"},"ClassName.N")," suffixes mean the index of the instance of the class created."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"DetoxCircusEnvironment.N")," is our custom ",(0,r.yg)("a",{parentName:"li",href:"https://jestjs.io/docs/configuration#testenvironment-string"},(0,r.yg)("inlineCode",{parentName:"a"},"testEnvironment"))," created one or multiple times in every Jest worker. Make sure to read about Jest ",(0,r.yg)("a",{parentName:"li",href:"https://jestjs.io/docs/configuration#testenvironment-string"},"test environments")," and look at the example section there for better understanding.")),(0,r.yg)(i.A,{mdxType:"Tabs"},(0,r.yg)(o.A,{value:"detox test \u2026 --maxWorkers N",mdxType:"TabItem"},(0,r.yg)(p,{mdxType:"LifecycleManyWorkersCLI"})),(0,r.yg)(o.A,{value:"jest \u2026 --maxWorkers N",mdxType:"TabItem"},(0,r.yg)(u,{mdxType:"LifecycleManyWorkersJest"})),(0,r.yg)(o.A,{value:"detox test \u2026 --runInBand",mdxType:"TabItem"},(0,r.yg)(h,{mdxType:"LifecycleSingleWorkerCLI"})),(0,r.yg)(o.A,{value:"jest \u2026 --runInBand",mdxType:"TabItem"},(0,r.yg)(N,{mdxType:"LifecycleSingleWorkerJest"}))),(0,r.yg)("h2",{id:"methods"},"Methods"),(0,r.yg)("admonition",{type:"info"},(0,r.yg)("p",{parentName:"admonition"},"Feel free to browse through ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/wix/Detox/blob/master/detox/internals.d.ts"},"the typings file")," provided by Detox.")),(0,r.yg)("h3",{id:"resolveconfigoptions-promiseruntimeconfig"},(0,r.yg)("inlineCode",{parentName:"h3"},"resolveConfig([options])")," ","[","Promise<RuntimeConfig",">","]"),(0,r.yg)("p",null,"Use sparingly for cases when you need to read Detox config before ",(0,r.yg)("a",{parentName:"p",href:"#initoptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"init()"))," is called."),(0,r.yg)("p",null,"If you use Detox with Jest, our default integration, the only place where you might need it is your ",(0,r.yg)("inlineCode",{parentName:"p"},"jest.config.js"),", e.g.:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js",metastring:'title="jest.config.js"',title:'"jest.config.js"'},"const { resolveConfig } = require('detox/internals');\n\nmodule.exports = async () => {\n  /** @type {DetoxInternals.RuntimeConfig} */\n  const config = await resolveConfig();\n\n  return { /* Jest config */ };\n};\n")),(0,r.yg)("p",null,"For example, you could use that to evaluate the ",(0,r.yg)("a",{parentName:"p",href:"https://jestjs.io/docs/configuration#maxworkers-number--string"},(0,r.yg)("inlineCode",{parentName:"a"},"maxWorkers"))," count depending on the device type,\nbut please mind, though, that Detox allows to override test runner options via its own config, e.g.:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js",metastring:'title="detox.config.js"',title:'"detox.config.js"'},"/** @type {Detox.DetoxConfig} */\nmodule.exports = {\n  apps: { /* ... */ },\n  devices: { /* ... */ },\n  configurations: {\n    'ios.sim.release': {\n      app: 'ios.release',\n      device: 'iphone',\n      testRunner: {\n        args: {\n// highlight-next-line\n          maxWorkers: process.env.CI === 'true' ? 3 : undefined,\n        },\n      },\n    },\n    'android.emu.release': {\n      app: 'android.release',\n      device: 'nexus',\n      testRunner: {\n        args: {\n// highlight-next-line\n          maxWorkers: process.env.CI === 'true' ? 2 : undefined,\n        },\n      },\n    },\n  },\n};\n")),(0,r.yg)("p",null,"This trick shown above allows to forward extra CLI arguments to ",(0,r.yg)("inlineCode",{parentName:"p"},"jest")," conditionally, e.g. when running in CI mode:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"CI=true detox test -c ios.sim.release\n# jest --config e2e/jest.config.js --maxWorkers 3\n")),(0,r.yg)("h3",{id:"getstatus-enum"},(0,r.yg)("inlineCode",{parentName:"h3"},"getStatus()")," ","[","enum]"),(0,r.yg)("p",null,"Returns one of statuses depending on what\u2019s going with the current Detox context:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"inactive")," \u2013 before ",(0,r.yg)("a",{parentName:"li",href:"#initoptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"init()"))," and after ",(0,r.yg)("a",{parentName:"li",href:"#cleanup-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"cleanup()"))," is called."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"init")," \u2013 while ",(0,r.yg)("a",{parentName:"li",href:"#initoptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"init()"))," is executing."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"active")," \u2013 after ",(0,r.yg)("a",{parentName:"li",href:"#initoptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"init()"))," and before ",(0,r.yg)("a",{parentName:"li",href:"#cleanup-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"cleanup()"))," is called."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"cleanup")," \u2013 while ",(0,r.yg)("a",{parentName:"li",href:"#cleanup-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"cleanup"))," is executing.")),(0,r.yg)("h3",{id:"initoptions-promise"},(0,r.yg)("inlineCode",{parentName:"h3"},"init([options])")," ","[","Promise]"),(0,r.yg)("p",null,"This is the phase where:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"a primary Detox context resolves its configuration, starts the logger, IPC server, and more;"),(0,r.yg)("li",{parentName:"ul"},"a secondary Detox context connects to IPC server and registers itself;"),(0,r.yg)("li",{parentName:"ul"},"if ",(0,r.yg)("inlineCode",{parentName:"li"},"workerId")," is not null, ",(0,r.yg)("a",{parentName:"li",href:"#installworkeroptions-promise"},"installs the worker"),";")),(0,r.yg)("p",null,"Accepts an optional parameter, ",(0,r.yg)("inlineCode",{parentName:"p"},"options")," object with the following properties, ",(0,r.yg)("em",{parentName:"p"},"all optional")," as well:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"cwd")," (string) \u2013 current working directory, used to ",(0,r.yg)("a",{parentName:"li",href:"/Detox/docs/config/overview#path-conventions"},"resolve Detox config"),"."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"argv")," (key-value map) \u2013 ",(0,r.yg)("strong",{parentName:"li"},"Internal!"),". CLI arguments parsed by Detox CLI."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"testRunnerArgv")," (key-value map) \u2013 CLI arguments to be forwarded to the test runner."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"override")," (Partial<Detox.DetoxConfig",">",") \u2013 ad-hoc adjustments to deep merge with the file-based config."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"global")," \u2013 reference to a custom ",(0,r.yg)("a",{parentName:"li",href:"https://nodejs.org/api/globals.html"},"global")," scope, usually needed when your test runner ",(0,r.yg)("a",{parentName:"li",href:"https://nodejs.org/api/vm.html"},"uses sandboxing"),".\nThis prevents creating issues when a Detox context cannot be accessed from within the sandboxed environment."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"workerId")," \u2013 (string ","|"," null) a unique ID, e.g. ",(0,r.yg)("inlineCode",{parentName:"li"},"worker-1"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"worker-2"),". Giving ",(0,r.yg)("inlineCode",{parentName:"li"},"null")," disables installing the worker.")),(0,r.yg)("h3",{id:"installworkeroptions-promise"},(0,r.yg)("inlineCode",{parentName:"h3"},"installWorker([options])")," ","[","Promise]"),(0,r.yg)("p",null,"This is the phase where Detox loads its expectation library and boots a device. You don't need to call it separately\nunless you use ",(0,r.yg)("a",{parentName:"p",href:"#initoptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"init({ workerId: null })"))," override."),(0,r.yg)("p",null,"Accepts an optional parameter, ",(0,r.yg)("inlineCode",{parentName:"p"},"options")," object with the following properties, ",(0,r.yg)("em",{parentName:"p"},"all optional")," as well:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"global")," \u2013 reference to a custom ",(0,r.yg)("a",{parentName:"li",href:"https://nodejs.org/api/globals.html"},"global")," scope, usually needed when your test runner ",(0,r.yg)("a",{parentName:"li",href:"https://nodejs.org/api/vm.html"},"uses sandboxing"),".\nThis prevents creating issues when a Detox context cannot be accessed from within the sandboxed environment."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"workerId")," \u2013 (string ","|"," null) a unique ID, e.g. ",(0,r.yg)("inlineCode",{parentName:"li"},"worker-1"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"worker-2"),". Giving ",(0,r.yg)("inlineCode",{parentName:"li"},"null")," disables installing the worker.")),(0,r.yg)("h3",{id:"uninstallworker-promise"},(0,r.yg)("inlineCode",{parentName:"h3"},"uninstallWorker()")," ","[","Promise]"),(0,r.yg)("p",null,"Deallocates the device. Most Client API (",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/api/device"},(0,r.yg)("inlineCode",{parentName:"a"},"device")),", ",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/api/matchers"},(0,r.yg)("inlineCode",{parentName:"a"},"by")),", ",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/api/actions"},(0,r.yg)("inlineCode",{parentName:"a"},"element")),", ",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/api/expect"},(0,r.yg)("inlineCode",{parentName:"a"},"expect")),") will stop working, except for ",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/api/logger"},"the logger"),"."),(0,r.yg)("h3",{id:"cleanup-promise"},(0,r.yg)("inlineCode",{parentName:"h3"},"cleanup()")," ","[","Promise]"),(0,r.yg)("p",null,"This method should be called when the main or child process is about to exit. Under the hood, it:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"#uninstallworker-promise"},"uninstalls the worker")," if there is a worker installed;"),(0,r.yg)("li",{parentName:"ul"},"a secondary Detox context disconnects from the ",(0,r.yg)("a",{parentName:"li",href:"https://www.npmjs.com/package/node-ipc"},"IPC server"),";"),(0,r.yg)("li",{parentName:"ul"},"a primary Detox context stops the IPC server and collects the log artifacts.")),(0,r.yg)("h2",{id:"optional-lifecycle"},"Optional lifecycle"),(0,r.yg)("h3",{id:"reporttestresultsarray-promise"},(0,r.yg)("inlineCode",{parentName:"h3"},"reportTestResults(array)")," ","[","Promise]"),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"This method has an effect only when the tests are run via ",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/cli/test"},"Detox CLI"),".")),(0,r.yg)("p",null,"Reports to the primary context about failed tests that could have been re-run if ",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/cli/test#options"},(0,r.yg)("inlineCode",{parentName:"a"},"-R, --retries"))," mechanism is enabled."),(0,r.yg)("p",null,"It takes one argument, an array of test file reports. Each report is an object with the following properties:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"testFilePath")," (string) \u2014 global or relative path to the failed test file;"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"success")," (boolean) \u2014 whether the test passed or not;"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"testExecError")," (optional error) \u2014 top-level error, use it only if the entire test file failed, e.g. due to a syntax error or environment setup failure;"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"isPermanentFailure")," (optional boolean) \u2014 if the test failed, it should tell whether the failure is permanent. Permanent failure means that the test file should not be re-run. For instance, we use it to ",(0,r.yg)("a",{parentName:"li",href:"/Detox/docs/config/testRunner#testrunnerjestretryaftercircusretries-boolean"},"prevent double retries"),": with Detox CLI and with ",(0,r.yg)("a",{parentName:"li",href:"https://jestjs.io/docs/jest-object#jestretrytimesnumretries-options"},(0,r.yg)("inlineCode",{parentName:"a"},"jest.retryTimes()")),".")),(0,r.yg)("h3",{id:"onrundescribestartevent-promise"},(0,r.yg)("inlineCode",{parentName:"h3"},"onRunDescribeStart(event)")," ","[","Promise]"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Requires an installed worker."),"\nReports that the test runner started executing a test suite, e.g. a ",(0,r.yg)("inlineCode",{parentName:"p"},"beforeAll")," hook or a first test:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"await onRunDescribeStart({\n  name: 'Suite name'\n});\n")),(0,r.yg)("h3",{id:"onteststartevent-promise"},(0,r.yg)("inlineCode",{parentName:"h3"},"onTestStart(event)")," ","[","Promise]"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Requires an installed worker."),"\nReports that the test runner started executing a specific test. Use ",(0,r.yg)("inlineCode",{parentName:"p"},"invocations")," when a test is being re-run after a failure:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"await onTestStart({\n  title: 'should do something expected',\n  fullName: 'Suite name should do something expected',\n  invocations: 1,\n  status: 'running',\n});\n")),(0,r.yg)("h3",{id:"onhookfailureevent-promise"},(0,r.yg)("inlineCode",{parentName:"h3"},"onHookFailure(event)")," ","[","Promise]"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Requires an installed worker."),"\nReports about an error in the midst of ",(0,r.yg)("inlineCode",{parentName:"p"},"beforeAll"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"beforeEach"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"afterEach"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"afterAll")," or any other hook. We use it, for example, to generate ",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/config/artifacts"},"screenshot artifacts")," like ",(0,r.yg)("inlineCode",{parentName:"p"},"beforeAllFailure.png"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"await onHookFailure({\n  error: new Error('Some assertion failed'),\n  hook: 'beforeEach',\n});\n")),(0,r.yg)("h3",{id:"ontestfnfailureevent-promise"},(0,r.yg)("inlineCode",{parentName:"h3"},"onTestFnFailure(event)")," ","[","Promise]"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Requires an installed worker."),"\nReports about an error in the midst of a test function. We use it, for example, to generate ",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/config/artifacts"},"screenshot artifacts")," like ",(0,r.yg)("inlineCode",{parentName:"p"},"testFnFailure.png"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"await onTestFnFailure({ error: new Error('Some assertion failed') });\n")),(0,r.yg)("h3",{id:"ontestdoneevent-promise"},(0,r.yg)("inlineCode",{parentName:"h3"},"onTestDone(event)")," ","[","Promise]"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Requires an installed worker."),"\nReports the final status of the test, ",(0,r.yg)("inlineCode",{parentName:"p"},"passed")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"failed"),", e.g.:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"await onTestDone({\n  title: 'should do something expected',\n  fullName: 'Suite name should do something expected',\n  invocations: 1,\n  status: 'failed',\n  timedOut: false,\n});\n")),(0,r.yg)("p",null,"Besides collecting ",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/config/artifacts"},"log, screenshot and video artifacts"),", this hook resets the pending network requests \u2013\nthese are usually some actions to which the app did not respond during the test. Setting ",(0,r.yg)("inlineCode",{parentName:"p"},"timedOut: true")," tells Detox to dump those pending requests, if there are any."),(0,r.yg)("p",null,"If your test runner supports re-running internally the failed tests, and, for example, your test passes on the second attempt, you would call the method with something like this:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"await onTestDone({\n  title: 'should do something expected',\n  fullName: 'Suite name should do something expected',\n  invocations: 2,\n  status: 'passed',\n});\n")),(0,r.yg)("h3",{id:"onrundescribefinishevent-promise"},(0,r.yg)("inlineCode",{parentName:"h3"},"onRunDescribeFinish(event)")," ","[","Promise]"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Requires an installed worker."),"\nReports that the test runner has finished executing a test suite, e.g. all the ",(0,r.yg)("inlineCode",{parentName:"p"},"afterAll")," hooks have been executed or the last test has finished running:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"await onRunDescribeFinish({ name: 'Suite name' });\n")),(0,r.yg)("h2",{id:"properties"},"Properties"),(0,r.yg)("h3",{id:"config-runtimeconfig"},(0,r.yg)("inlineCode",{parentName:"h3"},"config")," ","[","RuntimeConfig]"),(0,r.yg)("p",null,"Open ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/wix/Detox/blob/master/detox/internals.d.ts"},"the typings file")," and search for ",(0,r.yg)("inlineCode",{parentName:"p"},"RuntimeConfig"),"."),(0,r.yg)("p",null,"For the most part, this config is identical to what we describe in ",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/config/overview"},"Config docs"),", except that it is non-optional.\nIn other words, even if you never customized your ",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/config/session"},"Session config"),", you'll still be able to access some default\nvalues safely, without null checks."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"const { config } = require('detox/internals');\ntypeof config.session.autoStart // \"boolean\"\n")),(0,r.yg)("h3",{id:"session-sessionstate"},(0,r.yg)("inlineCode",{parentName:"h3"},"session")," ","[","SessionState]"),(0,r.yg)("p",null,"The session state contains the following read-only properties:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"id")," (string) \u2013 randomly generated ID for the entire Detox test session, including retries."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"testResults")," (DetoxTestFileReport[]) \u2013 results of the prior test file executions, used by Detox CLI retry mechanism."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"testSessionIndex")," (number) \u2013 the retry index of the test session: ",(0,r.yg)("inlineCode",{parentName:"li"},"0..<retriesCount>"),"."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"workersCount")," (number) \u2013 count of Detox contexts with a worker installed.\nIf we oversimplify it, it reflects the count of allocated devices in the current test session.")),(0,r.yg)("p",null,"The session state, including the resolved config, is serialized by the primary context, so that the secondary Detox contexts can read it synchronously from a file at the earliest point possible.\nAfter the secondary contexts connect to the IPC server hosted by the primary context, they register themselves and get the up-to-date session state.\nThe IPC server broadcasts the updates to all the connected contexts on every action like ",(0,r.yg)("a",{parentName:"p",href:"#installworkeroptions-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"installWorker()"))," or ",(0,r.yg)("a",{parentName:"p",href:"#reporttestresultsarray-promise"},(0,r.yg)("inlineCode",{parentName:"a"},"reportTestResults()")),"."),(0,r.yg)("h3",{id:"log-logger"},(0,r.yg)("inlineCode",{parentName:"h3"},"log")," ","[","Logger]"),(0,r.yg)("p",null,"See ",(0,r.yg)("a",{parentName:"p",href:"/Detox/docs/api/logger"},"Logger API")," for all the details."),(0,r.yg)("p",null,"The only difference from the Client API here is that you don't have a predefined ",(0,r.yg)("inlineCode",{parentName:"p"},"user")," category, i.e.:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"const { log: logClient } = require('detox');\nconst { log: logInternal } = require('detox/internals');\n\n// oversimplified, it looks like:\nlogClient == logInternal.child({ cat: 'user' })\n")),(0,r.yg)("p",null,"For example, we leverage this for adding more ",(0,r.yg)("inlineCode",{parentName:"p"},"lifecycle")," events in our integration with Jest:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js",metastring:'title="detox/runners/jest/testEnvironment/index.js"',title:'"detox/runners/jest/testEnvironment/index.js"'},"class DetoxCircusEnvironment extends NodeEnvironment {\n  constructor(config, context) {\n    super(/* ... */);\n    log.trace.begin({ cat: 'lifecycle' }, context.testPath);\n    // ...\n  }\n}\n")),(0,r.yg)("h3",{id:"tracing"},(0,r.yg)("inlineCode",{parentName:"h3"},"tracing")),(0,r.yg)("p",null,"An advanced API useful for creating reports based on logged Detox events."),(0,r.yg)("h4",{id:"tracingcreateeventstream"},(0,r.yg)("inlineCode",{parentName:"h4"},"tracing.createEventStream()")),(0,r.yg)("p",null,"Creates a readable stream of the currently recorded events in\n",(0,r.yg)("a",{parentName:"p",href:"https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU"},"Chrome Trace Event format"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"const { tracing } = require('detox/internals');\n\nasync function processDetoxEvents() {\n  await new Promise((resolve, reject) => {\n    tracing\n      .createEventStream()\n      .on('end', resolve)\n      .on('error', reject)\n      .on('data', (event) => {\n        if (event.ph === 'B') { /* duration event (begin) */ }\n        if (event.ph === 'E') { /* duration event (end) */ }\n        if (event.ph === 'i') { /* instant event */ }\n      });\n  });\n}\n")),(0,r.yg)("p",null,"Please mind that you'll be getting a snapshot of events aggregated from all the sibling and child processes, and it never will be complete until the very end of the test session."),(0,r.yg)("p",null,"See also: ",(0,r.yg)("a",{parentName:"p",href:"https://wix-incubator.github.io/trace-event-lib/interfaces/DurationBeginEvent.html"},(0,r.yg)("inlineCode",{parentName:"a"},"DurationBeginEvent")),", ",(0,r.yg)("a",{parentName:"p",href:"https://wix-incubator.github.io/trace-event-lib/interfaces/DurationEndEvent.html"},(0,r.yg)("inlineCode",{parentName:"a"},"DurationEndEvent")),", ",(0,r.yg)("a",{parentName:"p",href:"https://wix-incubator.github.io/trace-event-lib/interfaces/InstantEvent.html"},(0,r.yg)("inlineCode",{parentName:"a"},"InstantEvent")),"."),(0,r.yg)("h3",{id:"worker-object"},(0,r.yg)("inlineCode",{parentName:"h3"},"worker")," ","[","object]"),(0,r.yg)("p",null,"Not documented on purpose. Provides direct access to the object which holds the device driver, websocket client, matchers, expectations, etc."))}D.isMDXComponent=!0}}]);